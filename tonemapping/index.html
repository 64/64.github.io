<!doctype html><html lang=en><head><script src="https://www.googletagmanager.com/gtag/js?id=UA-140396812-1" async></script><script>window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());

	gtag('config', 'UA-140396812-1');</script><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="text/html; charset=utf-8" http-equiv=content-type><link href=/apple-touch-icon.png rel=apple-touch-icon sizes=180x180><link href=/favicon-64x64.png rel=icon type=image/png><link href=/site.webmanifest rel=manifest><link color=#7908cf href=/safari-pinned-tab.svg rel=mask-icon><meta content=#7908cf name=msapplication-TileColor><meta content=#7908cf name=theme-color><meta content="Tone Mapping" property=og:title><meta content=article property=og:type><meta property=og:description><meta content=/favicon-64x64.png property=og:image><meta content=https://64.github.io/tonemapping property=og:url><meta content=/favicon-64x64.png name=twitter:image><meta content="width=device-width,initial-scale=1.0,maximum-scale=1" name=viewport><title>Tone Mapping | δelta</title><script src=https://cdnjs.cloudflare.com/ajax/libs/slideout/1.0.1/slideout.min.js></script><meta content="dark light" name=color-scheme><link href=https://64.github.io/site-dark.css id=theme-link rel=stylesheet><link crossorigin=anonymous href=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css integrity=sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y rel=stylesheet><body><div class=container><div class=mobile-navbar id=mobile-navbar><div class=mobile-header-logo><a class=logo href=/>δ<span class=logo-text-alt>elta</span></a>: <span class=logo-subtitle> Blog by <a href=https://github.com/64>@64</a> </span></div><div class="mobile-navbar-icon icon-out"><span></span><span></span><span></span></div></div><nav class="mobile-menu slideout-menu slideout-menu-left" id=mobile-menu><ul class=mobile-menu-list><li class=mobile-menu-item><a href=https://64.github.io> Home </a><li class=mobile-menu-item><a href=https://64.github.io/categories> Categories </a><li class=mobile-menu-item><a class=nav-link href=https://github.com/64> GitHub <svg viewbox="0 0 24 24" class=mobile-menu-icon fill=none height=20 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=20 xmlns=http://www.w3.org/2000/svg><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg></a><li class=mobile-menu-item><a class=theme-toggle> Theme <span class=toggle-dark hidden><svg viewbox="0 0 24 24" class=mobile-menu-icon fill=none height=20 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=20 xmlns=http://www.w3.org/2000/svg><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg></span> <span class=toggle-light><svg viewbox="0 0 24 24" class=mobile-menu-icon fill=none height=20 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=20 xmlns=http://www.w3.org/2000/svg><circle cx=12 cy=12 r=5></circle><line x1=12 x2=12 y1=1 y2=3></line><line x1=12 x2=12 y1=21 y2=23></line><line x1=4.22 x2=5.64 y1=4.22 y2=5.64></line><line x1=18.36 x2=19.78 y1=18.36 y2=19.78></line><line x1=1 x2=3 y1=12 y2=12></line><line x1=21 x2=23 y1=12 y2=12></line><line x1=4.22 x2=5.64 y1=19.78 y2=18.36></line><line x1=18.36 x2=19.78 y1=5.64 y2=4.22></line></svg></span> </a></ul></nav><header id=header><div><div class=logo><a class=logo href=/>δ<span class=logo-text-alt>elta</span></a></div><div class=logo-subtitle>Blog by <a href=https://github.com/64>@64</a></div></div><nav class=menu><ul><li><a href=https://64.github.io> Home </a><li><a href=https://64.github.io/categories> Categories </a><li class=menu-separator><li class=menu-icon><a class=nav-link href=https://github.com/64><svg viewbox="0 0 24 24" fill=none height=20 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=20 xmlns=http://www.w3.org/2000/svg><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg></a><li class=menu-icon><a class=theme-toggle> <span class=toggle-dark hidden><svg viewbox="0 0 24 24" fill=none height=20 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=20 xmlns=http://www.w3.org/2000/svg><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg></span> <span class=toggle-light><svg viewbox="0 0 24 24" fill=none height=20 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=20 xmlns=http://www.w3.org/2000/svg><circle cx=12 cy=12 r=5></circle><line x1=12 x2=12 y1=1 y2=3></line><line x1=12 x2=12 y1=21 y2=23></line><line x1=4.22 x2=5.64 y1=4.22 y2=5.64></line><line x1=18.36 x2=19.78 y1=18.36 y2=19.78></line><line x1=1 x2=3 y1=12 y2=12></line><line x1=21 x2=23 y1=12 y2=12></line><line x1=4.22 x2=5.64 y1=19.78 y2=18.36></line><line x1=18.36 x2=19.78 y1=5.64 y2=4.22></line></svg></span> </a></ul></nav></header><main><div class=content id=mobile-panel><div class=post-toc id=post-toc><h2 class=post-toc-title>Contents</h2><div class="post-toc-content always-active"><nav id=TableOfContents><ul><li><a class=toc-link href=https://64.github.io/tonemapping/#reinhard>Reinhard</a><li><a class=toc-link href=https://64.github.io/tonemapping/#extended-reinhard>Extended Reinhard</a><li><a class=toc-link href=https://64.github.io/tonemapping/#luminance-and-color-theory>Luminance and Color Theory</a> <ul><li><a class=toc-link href=https://64.github.io/tonemapping/#extended-reinhard-luminance-tone-map>Extended Reinhard (Luminance Tone Map)</a><li><a class=toc-link href=https://64.github.io/tonemapping/#reinhard-jodie>Reinhard-Jodie</a></ul><li><a class=toc-link href=https://64.github.io/tonemapping/#filmic-tone-mapping-operators>Filmic Tone Mapping Operators</a> <ul><li><a class=toc-link href=https://64.github.io/tonemapping/#uncharted-2>Uncharted 2</a><li><a class=toc-link href=https://64.github.io/tonemapping/#aces>ACES</a></ul><li><a class=toc-link href=https://64.github.io/tonemapping/#real-camera-response-functions>Real Camera Response Functions</a><li><a class=toc-link href=https://64.github.io/tonemapping/#local-tone-mapping-operators>Local Tone Mapping Operators</a><li><a class=toc-link href=https://64.github.io/tonemapping/#conclusion>Conclusion</a> <ul><li><a class=toc-link href=https://64.github.io/tonemapping/#further-reading>Further Reading</a><li><a class=toc-link href=https://64.github.io/tonemapping/#appendix>Appendix</a></ul></ul></nav></div></div><article class=post><header class=post__header><h1 class=post__title><a href=https://64.github.io/tonemapping/>Tone Mapping</a></h1><div class=post__meta><span class=post__time>May 10, 2019</span><span class=post__readtime> • 17 minute read </span> • <span class=post__category> <a href=https://64.github.io/categories/graphics/>Graphics</a> </span></div></header><div class=post-content><p>Most monitors are capable of displaying RGB values in the range of <span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mo stretchy=false>[</mo><mn>0</mn><mo separator=true>,</mo><mn>255</mn><mo stretchy=false>]</mo></mrow><annotation encoding=application/x-tex>[0, 255]</annotation></semantics></math></span><span aria-hidden=true class=katex-html><span class=base><span class=strut style=height:1em;vertical-align:-0.25em;></span><span class=mopen>[</span><span class=mord>0</span><span class=mpunct>,</span><span class=mspace style=margin-right:0.1667em;></span><span class=mord>255</span><span class=mclose>]</span></span></span></span> . However, in real life, there is no limit on the amount of light 'energy' incident on a point. Most renderers output linear radiance values in <span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mo stretchy=false>[</mo><mn>0</mn><mo separator=true>,</mo><mi mathvariant=normal>∞</mi><mo stretchy=false>)</mo></mrow><annotation encoding=application/x-tex>[0, \infty)</annotation></semantics></math></span><span aria-hidden=true class=katex-html><span class=base><span class=strut style=height:1em;vertical-align:-0.25em;></span><span class=mopen>[</span><span class=mord>0</span><span class=mpunct>,</span><span class=mspace style=margin-right:0.1667em;></span><span class=mord>∞</span><span class=mclose>)</span></span></span></span> , which needs to be mapped into a viewable range. Those radiance values are described as High Dynamic Range (HDR), because they are unlimited, and the viewable target range is described as Low Dynamic Range (LDR), because there is a fixed limit of 255. Put simply, tone mapping is the process of mapping HDR values in <span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mo stretchy=false>[</mo><mn>0</mn><mo separator=true>,</mo><mi mathvariant=normal>∞</mi><mo stretchy=false>)</mo></mrow><annotation encoding=application/x-tex>[0, \infty)</annotation></semantics></math></span><span aria-hidden=true class=katex-html><span class=base><span class=strut style=height:1em;vertical-align:-0.25em;></span><span class=mopen>[</span><span class=mord>0</span><span class=mpunct>,</span><span class=mspace style=margin-right:0.1667em;></span><span class=mord>∞</span><span class=mclose>)</span></span></span></span> into LDR values (e.g values in <span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mo stretchy=false>[</mo><mn>0</mn><mo separator=true>,</mo><mn>255</mn><mo stretchy=false>]</mo></mrow><annotation encoding=application/x-tex>[0, 255]</annotation></semantics></math></span><span aria-hidden=true class=katex-html><span class=base><span class=strut style=height:1em;vertical-align:-0.25em;></span><span class=mopen>[</span><span class=mord>0</span><span class=mpunct>,</span><span class=mspace style=margin-right:0.1667em;></span><span class=mord>255</span><span class=mclose>]</span></span></span></span> or <span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mo stretchy=false>[</mo><mn>0.0</mn><mo separator=true>,</mo><mn>1.0</mn><mo stretchy=false>]</mo></mrow><annotation encoding=application/x-tex>[0.0, 1.0]</annotation></semantics></math></span><span aria-hidden=true class=katex-html><span class=base><span class=strut style=height:1em;vertical-align:-0.25em;></span><span class=mopen>[</span><span class=mord>0.0</span><span class=mpunct>,</span><span class=mspace style=margin-right:0.1667em;></span><span class=mord>1.0</span><span class=mclose>]</span></span></span></span> ).</p><span id=continue-reading></span><p>A <em>tone mapping operator</em> (TMO) is essentially just a function which maps an input color (e.g an RGB triple) to an output color:</p><span class=katex-display><span class=katex><span class=katex-mathml><math display=block xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><msub><mi>C</mi><mrow><mi mathvariant=normal>o</mi><mi mathvariant=normal>u</mi><mi mathvariant=normal>t</mi></mrow></msub><mo>=</mo><mrow><mi mathvariant=normal>T</mi><mi mathvariant=normal>M</mi><mi mathvariant=normal>O</mi></mrow><mo stretchy=false>(</mo><msub><mi>C</mi><mrow><mi mathvariant=normal>i</mi><mi mathvariant=normal>n</mi></mrow></msub><mo stretchy=false>)</mo></mrow><annotation encoding=application/x-tex>C_{\mathrm{out}} = \mathrm{TMO}(C_{\mathrm{in}})</annotation></semantics></math></span><span aria-hidden=true class=katex-html><span class=base><span class=strut style=height:0.8333em;vertical-align:-0.15em;></span><span class=mord><span class="mord mathnormal" style=margin-right:0.07153em;>C</span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:0.2806em;><span style=top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;><span class=pstrut style=height:2.7em;></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight">out</span></span></span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:0.15em;><span></span></span></span></span></span></span><span class=mspace style=margin-right:0.2778em;></span><span class=mrel>=</span><span class=mspace style=margin-right:0.2778em;></span></span><span class=base><span class=strut style=height:1em;vertical-align:-0.25em;></span><span class=mord><span class="mord mathrm">TMO</span></span><span class=mopen>(</span><span class=mord><span class="mord mathnormal" style=margin-right:0.07153em;>C</span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:0.3175em;><span style=top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;><span class=pstrut style=height:2.7em;></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight">in</span></span></span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:0.15em;><span></span></span></span></span></span></span><span class=mclose>)</span></span></span></span></span><p>At this point you might be a little confused as to why you've never had to think about tone mapping inside your program. If you're using an API like OpenGL, your radiance values are probably just being clamped by the implementation to <span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mo stretchy=false>[</mo><mn>0.0</mn><mo separator=true>,</mo><mn>1.0</mn><mo stretchy=false>]</mo></mrow><annotation encoding=application/x-tex>[0.0, 1.0]</annotation></semantics></math></span><span aria-hidden=true class=katex-html><span class=base><span class=strut style=height:1em;vertical-align:-0.25em;></span><span class=mopen>[</span><span class=mord>0.0</span><span class=mpunct>,</span><span class=mspace style=margin-right:0.1667em;></span><span class=mord>1.0</span><span class=mclose>]</span></span></span></span> in the final framebuffer. This is essentially a trivial tone mapping operator:</p><span class=katex-display><span class=katex><span class=katex-mathml><math display=block xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mrow><mi mathvariant=normal>T</mi><mi mathvariant=normal>M</mi><msub><mi mathvariant=normal>O</mi><mrow><mi mathvariant=normal>c</mi><mi mathvariant=normal>l</mi><mi mathvariant=normal>a</mi><mi mathvariant=normal>m</mi><mi mathvariant=normal>p</mi></mrow></msub></mrow><mo stretchy=false>(</mo><mi>C</mi><mo stretchy=false>)</mo><mo>=</mo><mrow><mi mathvariant=normal>c</mi><mi mathvariant=normal>l</mi><mi mathvariant=normal>a</mi><mi mathvariant=normal>m</mi><mi mathvariant=normal>p</mi></mrow><mo stretchy=false>(</mo><mi>C</mi><mo separator=true>,</mo><mn>0.0</mn><mo separator=true>,</mo><mn>1.0</mn><mo stretchy=false>)</mo></mrow><annotation encoding=application/x-tex>\mathrm{TMO_{clamp}}(C) = \mathrm{clamp}(C, 0.0, 1.0)</annotation></semantics></math></span><span aria-hidden=true class=katex-html><span class=base><span class=strut style=height:1.0361em;vertical-align:-0.2861em;></span><span class=mord><span class="mord mathrm">TM</span><span class=mord><span class="mord mathrm">O</span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:0.3361em;><span style=top:-2.55em;margin-left:0em;margin-right:0.05em;><span class=pstrut style=height:2.7em;></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">clamp</span></span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:0.2861em;><span></span></span></span></span></span></span></span><span class=mopen>(</span><span class="mord mathnormal" style=margin-right:0.07153em;>C</span><span class=mclose>)</span><span class=mspace style=margin-right:0.2778em;></span><span class=mrel>=</span><span class=mspace style=margin-right:0.2778em;></span></span><span class=base><span class=strut style=height:1em;vertical-align:-0.25em;></span><span class=mord><span class="mord mathrm">clamp</span></span><span class=mopen>(</span><span class="mord mathnormal" style=margin-right:0.07153em;>C</span><span class=mpunct>,</span><span class=mspace style=margin-right:0.1667em;></span><span class=mord>0.0</span><span class=mpunct>,</span><span class=mspace style=margin-right:0.1667em;></span><span class=mord>1.0</span><span class=mclose>)</span></span></span></span></span><p>This TMO, as you might guess, is quite flawed. Here's what it looks like when we apply this TMO to the memorial scene (the HDR scene file can be downloaded <a href=https://www.cs.huji.ac.il/%7Edanix/hdr/hdrs/memorial.hdr>here</a>):<figure><img src=/images/tonemap/clamp.png><figcaption><i>Tone mapping with clamp</i></figcaption></figure><p>High radiance values are being completely lost beyond a certain point. This results in the white areas (like the middle stained glass window) looking completely 'blown out'. For this particular scene it's not too bad because most of the radiance values are in <span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mo stretchy=false>[</mo><mn>0.0</mn><mo separator=true>,</mo><mn>1.0</mn><mo stretchy=false>]</mo></mrow><annotation encoding=application/x-tex>[0.0, 1.0]</annotation></semantics></math></span><span aria-hidden=true class=katex-html><span class=base><span class=strut style=height:1em;vertical-align:-0.25em;></span><span class=mopen>[</span><span class=mord>0.0</span><span class=mpunct>,</span><span class=mspace style=margin-right:0.1667em;></span><span class=mord>1.0</span><span class=mclose>]</span></span></span></span> already, but for a brighter outdoors scene it would look a lot worse. You could alleviate the issue somewhat by dividing the input color by some value before clamping:</p><span class=katex-display><span class=katex><span class=katex-mathml><math display=block xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mrow><mi mathvariant=normal>T</mi><mi mathvariant=normal>M</mi><msub><mi mathvariant=normal>O</mi><mrow><mi mathvariant=normal>c</mi><mi mathvariant=normal>l</mi><mi mathvariant=normal>a</mi><mi mathvariant=normal>m</mi><mi mathvariant=normal>p</mi><mn>2</mn></mrow></msub></mrow><mo stretchy=false>(</mo><mi>C</mi><mo stretchy=false>)</mo><mo>=</mo><mrow><mi mathvariant=normal>c</mi><mi mathvariant=normal>l</mi><mi mathvariant=normal>a</mi><mi mathvariant=normal>m</mi><mi mathvariant=normal>p</mi></mrow><mrow><mo fence=true>(</mo><mfrac><mi>C</mi><mi>k</mi></mfrac><mo separator=true>,</mo><mn>0.0</mn><mo separator=true>,</mo><mn>1.0</mn><mo fence=true>)</mo></mrow></mrow><annotation encoding=application/x-tex>\mathrm{TMO_{clamp2}}(C) = \mathrm{clamp}\left(\frac{C}{k}, 0.0, 1.0\right)</annotation></semantics></math></span><span aria-hidden=true class=katex-html><span class=base><span class=strut style=height:1.0361em;vertical-align:-0.2861em;></span><span class=mord><span class="mord mathrm">TM</span><span class=mord><span class="mord mathrm">O</span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:0.3361em;><span style=top:-2.55em;margin-left:0em;margin-right:0.05em;><span class=pstrut style=height:2.7em;></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">clamp2</span></span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:0.2861em;><span></span></span></span></span></span></span></span><span class=mopen>(</span><span class="mord mathnormal" style=margin-right:0.07153em;>C</span><span class=mclose>)</span><span class=mspace style=margin-right:0.2778em;></span><span class=mrel>=</span><span class=mspace style=margin-right:0.2778em;></span></span><span class=base><span class=strut style=height:2.4em;vertical-align:-0.95em;></span><span class=mord><span class="mord mathrm">clamp</span></span><span class=mspace style=margin-right:0.1667em;></span><span class=minner><span class="mopen delimcenter" style=top:0em;><span class="delimsizing size3">(</span></span><span class=mord><span class="mopen nulldelimiter"></span><span class=mfrac><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:1.3603em;><span style=top:-2.314em;><span class=pstrut style=height:3em;></span><span class=mord><span class="mord mathnormal" style=margin-right:0.03148em;>k</span></span></span><span style=top:-3.23em;><span class=pstrut style=height:3em;></span><span class=frac-line style=border-bottom-width:0.04em;></span></span><span style=top:-3.677em;><span class=pstrut style=height:3em;></span><span class=mord><span class="mord mathnormal" style=margin-right:0.07153em;>C</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:0.686em;><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class=mpunct>,</span><span class=mspace style=margin-right:0.1667em;></span><span class=mord>0.0</span><span class=mpunct>,</span><span class=mspace style=margin-right:0.1667em;></span><span class=mord>1.0</span><span class="mclose delimcenter" style=top:0em;><span class="delimsizing size3">)</span></span></span></span></span></span></span><p>However, as it turns out, we don't really want a linear relationship between input and output color. Human color perception is very non-linear - the difference between 1 light source and 2 light sources illuminating a point appears much greater than the difference between 100 light sources and 101 light sources. Non-linear TMOs are potentially able to reproduce images which can convey more detail to our eyes. Floats actually work great for storing HDR values for this exact reason - they have higher precision nearer zero, and lower precision as their value increases towards infinity.<p>The rest of this guide will explore a few simple tone mapping operators, as well as some underlying theory which should help you research the topic further.<h2 id=reinhard>Reinhard<a aria-hidden=true class=zola-anchor href=#reinhard><img src=/images/link.svg></a></h2><p>This is one of the simplest and most common TMOs, described by Reinhard et al. in <a href=https://www.cs.utah.edu/docs/techreports/2002/pdf/UUCS-02-001.pdf>this paper</a>. Simply put, it is:</p><span class=katex-display><span class=katex><span class=katex-mathml><math display=block xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mrow><mi mathvariant=normal>T</mi><mi mathvariant=normal>M</mi><msub><mi mathvariant=normal>O</mi><mrow><mi mathvariant=normal>r</mi><mi mathvariant=normal>e</mi><mi mathvariant=normal>i</mi><mi mathvariant=normal>n</mi><mi mathvariant=normal>h</mi><mi mathvariant=normal>a</mi><mi mathvariant=normal>r</mi><mi mathvariant=normal>d</mi></mrow></msub></mrow><mo stretchy=false>(</mo><mi>C</mi><mo stretchy=false>)</mo><mo>=</mo><mfrac><mi>C</mi><mrow><mn>1</mn><mo>+</mo><mi>C</mi></mrow></mfrac></mrow><annotation encoding=application/x-tex>\mathrm{TMO_{reinhard}}(C) = \frac{C}{1 + C}</annotation></semantics></math></span><span aria-hidden=true class=katex-html><span class=base><span class=strut style=height:1em;vertical-align:-0.25em;></span><span class=mord><span class="mord mathrm">TM</span><span class=mord><span class="mord mathrm">O</span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:0.3361em;><span style=top:-2.55em;margin-left:0em;margin-right:0.05em;><span class=pstrut style=height:2.7em;></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">reinhard</span></span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:0.15em;><span></span></span></span></span></span></span></span><span class=mopen>(</span><span class="mord mathnormal" style=margin-right:0.07153em;>C</span><span class=mclose>)</span><span class=mspace style=margin-right:0.2778em;></span><span class=mrel>=</span><span class=mspace style=margin-right:0.2778em;></span></span><span class=base><span class=strut style=height:2.1297em;vertical-align:-0.7693em;></span><span class=mord><span class="mopen nulldelimiter"></span><span class=mfrac><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:1.3603em;><span style=top:-2.314em;><span class=pstrut style=height:3em;></span><span class=mord><span class=mord>1</span><span class=mspace style=margin-right:0.2222em;></span><span class=mbin>+</span><span class=mspace style=margin-right:0.2222em;></span><span class="mord mathnormal" style=margin-right:0.07153em;>C</span></span></span><span style=top:-3.23em;><span class=pstrut style=height:3em;></span><span class=frac-line style=border-bottom-width:0.04em;></span></span><span style=top:-3.677em;><span class=pstrut style=height:3em;></span><span class=mord><span class="mord mathnormal" style=margin-right:0.07153em;>C</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:0.7693em;><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span><p>(Note that this isn't exactly what Reinhard is proposing in his paper, but more on that further down.)<p>This is mathematically guaranteed to produce a value in <span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mo stretchy=false>[</mo><mn>0.0</mn><mo separator=true>,</mo><mn>1.0</mn><mo stretchy=false>]</mo></mrow><annotation encoding=application/x-tex>[0.0, 1.0]</annotation></semantics></math></span><span aria-hidden=true class=katex-html><span class=base><span class=strut style=height:1em;vertical-align:-0.25em;></span><span class=mopen>[</span><span class=mord>0.0</span><span class=mpunct>,</span><span class=mspace style=margin-right:0.1667em;></span><span class=mord>1.0</span><span class=mclose>]</span></span></span></span> . By differentiating, you can see that <span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><msub><mi>C</mi><mrow><mi mathvariant=normal>o</mi><mi mathvariant=normal>u</mi><mi mathvariant=normal>t</mi></mrow></msub></mrow><annotation encoding=application/x-tex>C_{\mathrm{out}}</annotation></semantics></math></span><span aria-hidden=true class=katex-html><span class=base><span class=strut style=height:0.8333em;vertical-align:-0.15em;></span><span class=mord><span class="mord mathnormal" style=margin-right:0.07153em;>C</span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:0.2806em;><span style=top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;><span class=pstrut style=height:2.7em;></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight">out</span></span></span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:0.15em;><span></span></span></span></span></span></span></span></span></span> has an inverse-square falloff (e.g a radiance value of 4 results in something which is only 1.2 times as bright as a radiance value of 2).<p>In C++:<pre class=language-cpp data-lang=cpp style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-cpp data-lang=cpp><span>vec3 reinhard(vec3 v)
</span><span>{
</span><span>    </span><span style=color:#569cd6;>return</span><span> v / (</span><span style=color:#b5cea8;>1.0</span><span style=color:#569cd6;>f </span><span>+ v);
</span><span>}
</span></code></pre><p>Compare this image to the previous 'clamp' TMO. Reinhard looks much more grey-ish, and the whites are less blown out (more detail is noticeable in the middle stained glass window).<figure><img src=/images/tonemap/reinhard.png><figcaption><i>Reinhard tone mapping</i></figcaption></figure><h2 id=extended-reinhard>Extended Reinhard<a aria-hidden=true class=zola-anchor href=#extended-reinhard><img src=/images/link.svg></a></h2><p>The problem with the 'simple' Reinhard TMO is that it doesn't necessarily make good use of the full Low Dynamic Range. If our max scene radiance happened to be <span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mo stretchy=false>(</mo><mn>1.0</mn><mo separator=true>,</mo><mn>1.0</mn><mo separator=true>,</mo><mn>1.0</mn><mo stretchy=false>)</mo></mrow><annotation encoding=application/x-tex>(1.0, 1.0, 1.0)</annotation></semantics></math></span><span aria-hidden=true class=katex-html><span class=base><span class=strut style=height:1em;vertical-align:-0.25em;></span><span class=mopen>(</span><span class=mord>1.0</span><span class=mpunct>,</span><span class=mspace style=margin-right:0.1667em;></span><span class=mord>1.0</span><span class=mpunct>,</span><span class=mspace style=margin-right:0.1667em;></span><span class=mord>1.0</span><span class=mclose>)</span></span></span></span> then the resulting maximum brightness would only be <span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mo stretchy=false>(</mo><mn>0.5</mn><mo separator=true>,</mo><mn>0.5</mn><mo separator=true>,</mo><mn>0.5</mn><mo stretchy=false>)</mo></mrow><annotation encoding=application/x-tex>(0.5, 0.5, 0.5)</annotation></semantics></math></span><span aria-hidden=true class=katex-html><span class=base><span class=strut style=height:1em;vertical-align:-0.25em;></span><span class=mopen>(</span><span class=mord>0.5</span><span class=mpunct>,</span><span class=mspace style=margin-right:0.1667em;></span><span class=mord>0.5</span><span class=mpunct>,</span><span class=mspace style=margin-right:0.1667em;></span><span class=mord>0.5</span><span class=mclose>)</span></span></span></span> - only half of the available range. Fortunately, the paper by Reinhard presents a way to scale and make use of the full range:</p><span class=katex-display><span class=katex><span class=katex-mathml><math display=block xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mrow><mi mathvariant=normal>T</mi><mi mathvariant=normal>M</mi><msub><mi mathvariant=normal>O</mi><mrow><mi mathvariant=normal>r</mi><mi mathvariant=normal>e</mi><mi mathvariant=normal>i</mi><mi mathvariant=normal>n</mi><mi mathvariant=normal>h</mi><mi mathvariant=normal>a</mi><mi mathvariant=normal>r</mi><mi mathvariant=normal>d</mi><mi mathvariant=normal>e</mi><mi mathvariant=normal>x</mi><mi mathvariant=normal>t</mi></mrow></msub></mrow><mo stretchy=false>(</mo><mi>C</mi><mo stretchy=false>)</mo><mo>=</mo><mfrac><mrow><mi>C</mi><mrow><mo fence=true>(</mo><mn>1</mn><mo>+</mo><mfrac><mi>C</mi><msubsup><mi>C</mi><mrow><mi mathvariant=normal>w</mi><mi mathvariant=normal>h</mi><mi mathvariant=normal>i</mi><mi mathvariant=normal>t</mi><mi mathvariant=normal>e</mi></mrow><mn>2</mn></msubsup></mfrac><mo fence=true>)</mo></mrow></mrow><mrow><mn>1</mn><mo>+</mo><mi>C</mi></mrow></mfrac></mrow><annotation encoding=application/x-tex>\mathrm{TMO_{reinhardext}}(C) = \frac{C\left(1 + \frac{C}{C_{\mathrm{white}}^2}\right)}{1 + C}</annotation></semantics></math></span><span aria-hidden=true class=katex-html><span class=base><span class=strut style=height:1em;vertical-align:-0.25em;></span><span class=mord><span class="mord mathrm">TM</span><span class=mord><span class="mord mathrm">O</span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:0.3361em;><span style=top:-2.55em;margin-left:0em;margin-right:0.05em;><span class=pstrut style=height:2.7em;></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">reinhardext</span></span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:0.15em;><span></span></span></span></span></span></span></span><span class=mopen>(</span><span class="mord mathnormal" style=margin-right:0.07153em;>C</span><span class=mclose>)</span><span class=mspace style=margin-right:0.2778em;></span><span class=mrel>=</span><span class=mspace style=margin-right:0.2778em;></span></span><span class=base><span class=strut style=height:2.9594em;vertical-align:-0.7693em;></span><span class=mord><span class="mopen nulldelimiter"></span><span class=mfrac><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:2.19em;><span style=top:-2.464em;><span class=pstrut style=height:3.15em;></span><span class=mord><span class=mord>1</span><span class=mspace style=margin-right:0.2222em;></span><span class=mbin>+</span><span class=mspace style=margin-right:0.2222em;></span><span class="mord mathnormal" style=margin-right:0.07153em;>C</span></span></span><span style=top:-3.38em;><span class=pstrut style=height:3.15em;></span><span class=frac-line style=border-bottom-width:0.04em;></span></span><span style=top:-4.19em;><span class=pstrut style=height:3.15em;></span><span class=mord><span class="mord mathnormal" style=margin-right:0.07153em;>C</span><span class=mspace style=margin-right:0.1667em;></span><span class=minner><span class="mopen delimcenter" style=top:0em;><span class="delimsizing size2">(</span></span><span class=mord>1</span><span class=mspace style=margin-right:0.2222em;></span><span class=mbin>+</span><span class=mspace style=margin-right:0.2222em;></span><span class=mord><span class="mopen nulldelimiter"></span><span class=mfrac><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:0.8723em;><span style=top:-2.6264em;><span class=pstrut style=height:3em;></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style=margin-right:0.07153em;>C</span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:0.8051em;><span style=top:-2.1528em;margin-left:-0.0715em;margin-right:0.0714em;><span class=pstrut style=height:2.5em;></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight">white</span></span></span></span></span><span style=top:-2.8448em;margin-right:0.0714em;><span class=pstrut style=height:2.5em;></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:0.3472em;><span></span></span></span></span></span></span></span></span></span><span style=top:-3.23em;><span class=pstrut style=height:3em;></span><span class=frac-line style=border-bottom-width:0.04em;></span></span><span style=top:-3.394em;><span class=pstrut style=height:3em;></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style=margin-right:0.07153em;>C</span></span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:0.6166em;><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style=top:0em;><span class="delimsizing size2">)</span></span></span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:0.7693em;><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span><p>where <span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><msub><mi>C</mi><mrow><mi mathvariant=normal>w</mi><mi mathvariant=normal>h</mi><mi mathvariant=normal>i</mi><mi mathvariant=normal>t</mi><mi mathvariant=normal>e</mi></mrow></msub></mrow><annotation encoding=application/x-tex>C_{\mathrm{white}}</annotation></semantics></math></span><span aria-hidden=true class=katex-html><span class=base><span class=strut style=height:0.8333em;vertical-align:-0.15em;></span><span class=mord><span class="mord mathnormal" style=margin-right:0.07153em;>C</span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:0.3361em;><span style=top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;><span class=pstrut style=height:2.7em;></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight">white</span></span></span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:0.15em;><span></span></span></span></span></span></span></span></span></span> is the biggest radiance value in the scene. Now, our biggest radiance value will get mapped to <span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mo stretchy=false>(</mo><mn>1.0</mn><mo separator=true>,</mo><mn>1.0</mn><mo separator=true>,</mo><mn>1.0</mn><mo stretchy=false>)</mo></mrow><annotation encoding=application/x-tex>(1.0, 1.0, 1.0)</annotation></semantics></math></span><span aria-hidden=true class=katex-html><span class=base><span class=strut style=height:1em;vertical-align:-0.25em;></span><span class=mopen>(</span><span class=mord>1.0</span><span class=mpunct>,</span><span class=mspace style=margin-right:0.1667em;></span><span class=mord>1.0</span><span class=mpunct>,</span><span class=mspace style=margin-right:0.1667em;></span><span class=mord>1.0</span><span class=mclose>)</span></span></span></span> , using the full LDR.<p>(Note that you can also just set <span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><msub><mi>C</mi><mrow><mi mathvariant=normal>w</mi><mi mathvariant=normal>h</mi><mi mathvariant=normal>i</mi><mi mathvariant=normal>t</mi><mi mathvariant=normal>e</mi></mrow></msub></mrow><annotation encoding=application/x-tex>C_\mathrm{white}</annotation></semantics></math></span><span aria-hidden=true class=katex-html><span class=base><span class=strut style=height:0.8333em;vertical-align:-0.15em;></span><span class=mord><span class="mord mathnormal" style=margin-right:0.07153em;>C</span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:0.3361em;><span style=top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;><span class=pstrut style=height:2.7em;></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">white</span></span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:0.15em;><span></span></span></span></span></span></span></span></span></span> to a value lower than the maximum radiance, which will ensure that anything higher gets mapped to <span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mo stretchy=false>(</mo><mn>1.0</mn><mo separator=true>,</mo><mn>1.0</mn><mo separator=true>,</mo><mn>1.0</mn><mo stretchy=false>)</mo></mrow><annotation encoding=application/x-tex>(1.0, 1.0, 1.0)</annotation></semantics></math></span><span aria-hidden=true class=katex-html><span class=base><span class=strut style=height:1em;vertical-align:-0.25em;></span><span class=mopen>(</span><span class=mord>1.0</span><span class=mpunct>,</span><span class=mspace style=margin-right:0.1667em;></span><span class=mord>1.0</span><span class=mpunct>,</span><span class=mspace style=margin-right:0.1667em;></span><span class=mord>1.0</span><span class=mclose>)</span></span></span></span> - for this reason it is sometimes referred to as the 'white point'.)<p>In C++:<pre class=language-cpp data-lang=cpp style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-cpp data-lang=cpp><span>vec3 reinhard_extended(vec3 v, </span><span style=color:#569cd6;>float </span><span>max_white)
</span><span>{
</span><span>    vec3 numerator = v </span><span style=color:#569cd6;>* </span><span>(</span><span style=color:#b5cea8;>1.0</span><span style=color:#569cd6;>f </span><span>+ (v / vec3(max_white </span><span style=color:#569cd6;>*</span><span> max_white)));
</span><span>    </span><span style=color:#569cd6;>return</span><span> numerator / (</span><span style=color:#b5cea8;>1.0</span><span style=color:#569cd6;>f </span><span>+ v);
</span><span>}
</span></code></pre><p>If we just set our max scene radiance as the white point, this TMO appears almost exactly the same as the simple reinhard operator. That's because the max radiance for this scene is 622, and <span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mfrac><mn>622</mn><mrow><mn>1</mn><mo>+</mo><mn>622</mn></mrow></mfrac><mo>≈</mo><mn>0.998</mn></mrow><annotation encoding=application/x-tex>\frac{622}{1+622} \approx 0.998</annotation></semantics></math></span><span aria-hidden=true class=katex-html><span class=base><span class=strut style=height:1.2484em;vertical-align:-0.4033em;></span><span class=mord><span class="mopen nulldelimiter"></span><span class=mfrac><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:0.8451em;><span style=top:-2.655em;><span class=pstrut style=height:3em;></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">+</span><span class="mord mtight">622</span></span></span></span><span style=top:-3.23em;><span class=pstrut style=height:3em;></span><span class=frac-line style=border-bottom-width:0.04em;></span></span><span style=top:-3.394em;><span class=pstrut style=height:3em;></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">622</span></span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:0.4033em;><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class=mspace style=margin-right:0.2778em;></span><span class=mrel>≈</span><span class=mspace style=margin-right:0.2778em;></span></span><span class=base><span class=strut style=height:0.6444em;></span><span class=mord>0.998</span></span></span></span> , so the difference between the extended and the simple variants in this case is imperceptible - simple reinhard was already making full use of the low dynamic range. If we used a different white point, the TMO would look noticeably different.<h1 id=luminance-and-color-theory>Luminance and Color Theory<a aria-hidden=true class=zola-anchor href=#luminance-and-color-theory><img src=/images/link.svg></a></h1><p>Okay, so I must admit that I've lied to you slightly. Reinhard's formulas actually operate on a thing called <em>luminance</em> rather than operating on RGB-triples as I implied. Luminance is a single scalar value which measures how bright we view something. It may not be obvious, but for example we perceive green as much brighter than blue. In other words, <span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mo stretchy=false>(</mo><mn>0.0</mn><mo separator=true>,</mo><mn>0.7</mn><mo separator=true>,</mo><mn>0.0</mn><mo stretchy=false>)</mo></mrow><annotation encoding=application/x-tex>(0.0, 0.7, 0.0)</annotation></semantics></math></span><span aria-hidden=true class=katex-html><span class=base><span class=strut style=height:1em;vertical-align:-0.25em;></span><span class=mopen>(</span><span class=mord>0.0</span><span class=mpunct>,</span><span class=mspace style=margin-right:0.1667em;></span><span class=mord>0.7</span><span class=mpunct>,</span><span class=mspace style=margin-right:0.1667em;></span><span class=mord>0.0</span><span class=mclose>)</span></span></span></span> appears much brighter than <span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mo stretchy=false>(</mo><mn>0.0</mn><mo separator=true>,</mo><mn>0.0</mn><mo separator=true>,</mo><mn>0.7</mn><mo stretchy=false>)</mo></mrow><annotation encoding=application/x-tex>(0.0, 0.0, 0.7)</annotation></semantics></math></span><span aria-hidden=true class=katex-html><span class=base><span class=strut style=height:1em;vertical-align:-0.25em;></span><span class=mopen>(</span><span class=mord>0.0</span><span class=mpunct>,</span><span class=mspace style=margin-right:0.1667em;></span><span class=mord>0.0</span><span class=mpunct>,</span><span class=mspace style=margin-right:0.1667em;></span><span class=mord>0.7</span><span class=mclose>)</span></span></span></span> .<p>Converting a linear RGB triple to a luminance value is easy:</p><span class=katex-display><span class=katex><span class=katex-mathml><math display=block xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mi>L</mi><mo>=</mo><mn>0.2126</mn><mi>R</mi><mo>+</mo><mn>0.7152</mn><mi>G</mi><mo>+</mo><mn>0.0722</mn><mi>B</mi></mrow><annotation encoding=application/x-tex>L = 0.2126R + 0.7152G + 0.0722B</annotation></semantics></math></span><span aria-hidden=true class=katex-html><span class=base><span class=strut style=height:0.6833em;></span><span class="mord mathnormal">L</span><span class=mspace style=margin-right:0.2778em;></span><span class=mrel>=</span><span class=mspace style=margin-right:0.2778em;></span></span><span class=base><span class=strut style=height:0.7667em;vertical-align:-0.0833em;></span><span class=mord>0.2126</span><span class="mord mathnormal" style=margin-right:0.00773em;>R</span><span class=mspace style=margin-right:0.2222em;></span><span class=mbin>+</span><span class=mspace style=margin-right:0.2222em;></span></span><span class=base><span class=strut style=height:0.7667em;vertical-align:-0.0833em;></span><span class=mord>0.7152</span><span class="mord mathnormal">G</span><span class=mspace style=margin-right:0.2222em;></span><span class=mbin>+</span><span class=mspace style=margin-right:0.2222em;></span></span><span class=base><span class=strut style=height:0.6833em;></span><span class=mord>0.0722</span><span class="mord mathnormal" style=margin-right:0.05017em;>B</span></span></span></span></span><p>So far we've effectively been applying our TMOs to each RGB channel individually. However this can cause a 'shift' in hue or saturation which can significantly change the color appearance.<p>Instead, what Reinhard's formula entails is to convert our linear RGB radiance to luminance, apply tone mapping the luminance, then somehow scale our RGB value by the new luminance. The simplest way of doing that final scaling is:</p><span class=katex-display><span class=katex><span class=katex-mathml><math display=block xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><msub><mi>C</mi><mrow><mi mathvariant=normal>o</mi><mi mathvariant=normal>u</mi><mi mathvariant=normal>t</mi></mrow></msub><mo>=</mo><msub><mi>C</mi><mrow><mi mathvariant=normal>i</mi><mi mathvariant=normal>n</mi></mrow></msub><mfrac><msub><mi>L</mi><mrow><mi mathvariant=normal>o</mi><mi mathvariant=normal>u</mi><mi mathvariant=normal>t</mi></mrow></msub><msub><mi>L</mi><mrow><mi mathvariant=normal>i</mi><mi mathvariant=normal>n</mi></mrow></msub></mfrac></mrow><annotation encoding=application/x-tex>C_{\mathrm{out}} = C_{\mathrm{in}} \frac{L_{\mathrm{out}}}{L_{\mathrm{in}}}</annotation></semantics></math></span><span aria-hidden=true class=katex-html><span class=base><span class=strut style=height:0.8333em;vertical-align:-0.15em;></span><span class=mord><span class="mord mathnormal" style=margin-right:0.07153em;>C</span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:0.2806em;><span style=top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;><span class=pstrut style=height:2.7em;></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight">out</span></span></span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:0.15em;><span></span></span></span></span></span></span><span class=mspace style=margin-right:0.2778em;></span><span class=mrel>=</span><span class=mspace style=margin-right:0.2778em;></span></span><span class=base><span class=strut style=height:2.1963em;vertical-align:-0.836em;></span><span class=mord><span class="mord mathnormal" style=margin-right:0.07153em;>C</span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:0.3175em;><span style=top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;><span class=pstrut style=height:2.7em;></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight">in</span></span></span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:0.15em;><span></span></span></span></span></span></span><span class=mord><span class="mopen nulldelimiter"></span><span class=mfrac><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:1.3603em;><span style=top:-2.314em;><span class=pstrut style=height:3em;></span><span class=mord><span class=mord><span class="mord mathnormal">L</span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:0.3175em;><span style=top:-2.55em;margin-left:0em;margin-right:0.05em;><span class=pstrut style=height:2.7em;></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight">in</span></span></span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:0.15em;><span></span></span></span></span></span></span></span></span><span style=top:-3.23em;><span class=pstrut style=height:3em;></span><span class=frac-line style=border-bottom-width:0.04em;></span></span><span style=top:-3.677em;><span class=pstrut style=height:3em;></span><span class=mord><span class=mord><span class="mord mathnormal">L</span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:0.2806em;><span style=top:-2.55em;margin-left:0em;margin-right:0.05em;><span class=pstrut style=height:2.7em;></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight">out</span></span></span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:0.15em;><span></span></span></span></span></span></span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:0.836em;><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span><p>In C++:<pre class=language-cpp data-lang=cpp style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-cpp data-lang=cpp><span style=color:#569cd6;>float </span><span>luminance(vec3 v)
</span><span>{
</span><span>    </span><span style=color:#569cd6;>return </span><span>dot(v, vec3(</span><span style=color:#b5cea8;>0.2126</span><span style=color:#569cd6;>f</span><span>, </span><span style=color:#b5cea8;>0.7152</span><span style=color:#569cd6;>f</span><span>, </span><span style=color:#b5cea8;>0.0722</span><span style=color:#569cd6;>f</span><span>));
</span><span>}
</span><span>
</span><span>vec3 change_luminance(vec3 c_in, </span><span style=color:#569cd6;>float </span><span>l_out)
</span><span>{
</span><span>    </span><span style=color:#569cd6;>float</span><span> l_in = luminance(c_in);
</span><span>    </span><span style=color:#569cd6;>return</span><span> c_in </span><span style=color:#569cd6;>* </span><span>(l_out / l_in);
</span><span>}
</span></code></pre><p>Two other more complex luminance-adjusting methods are discussed in <a href=https://www.cl.cam.ac.uk/%7Erkm38/pdfs/mantiuk09cctm.pdf>a paper</a> by Mantiuk et al., but the simple method is perfectly acceptable.<p>Don't confuse <em>luminance</em> with <em>luma</em> - luma is the equivalent of the luminance computed from an sRGB pixel (i.e gamma-corrected). The coefficients used to convert to luma are the same as luminance, they just operate on sRGB components instead. See <a href=https://en.wikipedia.org/wiki/Luma_(video)>Wikipedia</a> for more details.<p>Note that the hue / saturation preservation which results from this method isn't always desirable. Reinhard tone mapping in particular was created with the intention of being applied to luminance only, so it looks much better when this is done (see the following section for details on that). Other tone mapping curves look better when applied to RGB components separately.<blockquote><p>Reinhard was on the wrong track in applying his tone mapping curve to luminance; his curve was inspired by film, but film curves are applied to each color channel separately. And that is a good thing - [...] the "hue and saturation shifts" (really mostly saturation shifts) resulting from applying nonlinear curves per channel are an important feature, not a bug.<p>-- <a href=https://imdoingitwrong.wordpress.com/2010/08/19/why-reinhard-desaturates-my-blacks-3/#comment-3>Naty Hoffman, co-author of Real Time Rendering</a></blockquote><h2 id=extended-reinhard-luminance-tone-map>Extended Reinhard (Luminance Tone Map)<a aria-hidden=true class=zola-anchor href=#extended-reinhard-luminance-tone-map><img src=/images/link.svg></a></h2><p>Let's apply the extended Reinhard TMO to luminance only:<pre class=language-cpp data-lang=cpp style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-cpp data-lang=cpp><span>vec3 reinhard_extended_luminance(vec3 v, </span><span style=color:#569cd6;>float </span><span>max_white_l)
</span><span>{
</span><span>    </span><span style=color:#569cd6;>float</span><span> l_old = luminance(v);
</span><span>    </span><span style=color:#569cd6;>float</span><span> numerator = l_old </span><span style=color:#569cd6;>* </span><span>(</span><span style=color:#b5cea8;>1.0</span><span style=color:#569cd6;>f </span><span>+ (l_old / (max_white_l </span><span style=color:#569cd6;>*</span><span> max_white_l)));
</span><span>    </span><span style=color:#569cd6;>float</span><span> l_new = numerator / (</span><span style=color:#b5cea8;>1.0</span><span style=color:#569cd6;>f </span><span>+ l_old);
</span><span>    </span><span style=color:#569cd6;>return </span><span>change_luminance(v, l_new);
</span><span>}
</span></code></pre><p>Here's the difference it makes - the stained glass windows and the column on the left are noticeably more orange and less 'washed out' in the luminance mapped version:<div class=image-grid-row><div class=image-grid-col><figure><img src=/images/tonemap/reinhard-rgb.png><figcaption><i>Reinhard applied to RGB channels</i></figcaption></figure></div><div class=image-grid-col><figure><img src=/images/tonemap/reinhard-luminance.png><figcaption><i>Reinhard applied to luminance</i></figcaption></figure></div></div><p>Note that in fact with Reinhard, the luminance calculation can be simplified somewhat:</p><span class=katex-display><span class=katex><span class=katex-mathml><math display=block xmlns=http://www.w3.org/1998/Math/MathML><semantics><mtable columnalign="right left" columnspacing=0em rowspacing=0.25em><mtr><mtd><mstyle displaystyle=true scriptlevel=0><msub><mi>L</mi><mrow><mi mathvariant=normal>o</mi><mi mathvariant=normal>u</mi><mi mathvariant=normal>t</mi></mrow></msub></mstyle></mtd><mtd><mstyle displaystyle=true scriptlevel=0><mrow><mrow></mrow><mo>=</mo><mfrac><msub><mi>L</mi><mrow><mi mathvariant=normal>i</mi><mi mathvariant=normal>n</mi></mrow></msub><mrow><mn>1.0</mn><mo>+</mo><msub><mi>L</mi><mrow><mi mathvariant=normal>i</mi><mi mathvariant=normal>n</mi></mrow></msub></mrow></mfrac></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle displaystyle=true scriptlevel=0><mrow><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><mfrac><msub><mi>L</mi><mrow><mi mathvariant=normal>o</mi><mi mathvariant=normal>u</mi><mi mathvariant=normal>t</mi></mrow></msub><msub><mi>L</mi><mrow><mi mathvariant=normal>i</mi><mi mathvariant=normal>n</mi></mrow></msub></mfrac></mrow></mstyle></mtd><mtd><mstyle displaystyle=true scriptlevel=0><mrow><mrow></mrow><mo>=</mo><mfrac><mn>1.0</mn><mrow><mn>1.0</mn><mo>+</mo><msub><mi>L</mi><mrow><mi mathvariant=normal>i</mi><mi mathvariant=normal>n</mi></mrow></msub></mrow></mfrac></mrow></mstyle></mtd></mtr></mtable><annotation encoding=application/x-tex>\begin{aligned} L_\mathrm{out} &= \frac{L_\mathrm{in}}{1.0 + L_\mathrm{in}} \\ \implies \frac{L_\mathrm{out}}{L_\mathrm{in}} &= \frac{1.0}{1.0 + L_\mathrm{in}} \end{aligned}</annotation></semantics></math></span><span aria-hidden=true class=katex-html><span class=base><span class=strut style=height:4.9927em;vertical-align:-2.2463em;></span><span class=mord><span class=mtable><span class=col-align-r><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:2.7463em;><span style=top:-4.7463em;><span class=pstrut style=height:3.3603em;></span><span class=mord><span class=mord><span class="mord mathnormal">L</span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:0.2806em;><span style=top:-2.55em;margin-left:0em;margin-right:0.05em;><span class=pstrut style=height:2.7em;></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">out</span></span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:0.15em;><span></span></span></span></span></span></span></span></span><span style=top:-2.25em;><span class=pstrut style=height:3.3603em;></span><span class=mord><span class=mspace style=margin-right:0.2778em;></span><span class=mrel>⟹</span><span class=mspace style=margin-right:0.2778em;></span><span class=mspace style=margin-right:0.2778em;></span><span class=mord><span class="mopen nulldelimiter"></span><span class=mfrac><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:1.3603em;><span style=top:-2.314em;><span class=pstrut style=height:3em;></span><span class=mord><span class=mord><span class="mord mathnormal">L</span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:0.3175em;><span style=top:-2.55em;margin-left:0em;margin-right:0.05em;><span class=pstrut style=height:2.7em;></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">in</span></span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:0.15em;><span></span></span></span></span></span></span></span></span><span style=top:-3.23em;><span class=pstrut style=height:3em;></span><span class=frac-line style=border-bottom-width:0.04em;></span></span><span style=top:-3.677em;><span class=pstrut style=height:3em;></span><span class=mord><span class=mord><span class="mord mathnormal">L</span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:0.2806em;><span style=top:-2.55em;margin-left:0em;margin-right:0.05em;><span class=pstrut style=height:2.7em;></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">out</span></span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:0.15em;><span></span></span></span></span></span></span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:0.836em;><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:2.2463em;><span></span></span></span></span></span><span class=col-align-l><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:2.7463em;><span style=top:-4.7463em;><span class=pstrut style=height:3.3603em;></span><span class=mord><span class=mord></span><span class=mspace style=margin-right:0.2778em;></span><span class=mrel>=</span><span class=mspace style=margin-right:0.2778em;></span><span class=mord><span class="mopen nulldelimiter"></span><span class=mfrac><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:1.3603em;><span style=top:-2.314em;><span class=pstrut style=height:3em;></span><span class=mord><span class=mord>1.0</span><span class=mspace style=margin-right:0.2222em;></span><span class=mbin>+</span><span class=mspace style=margin-right:0.2222em;></span><span class=mord><span class="mord mathnormal">L</span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:0.3175em;><span style=top:-2.55em;margin-left:0em;margin-right:0.05em;><span class=pstrut style=height:2.7em;></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">in</span></span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:0.15em;><span></span></span></span></span></span></span></span></span><span style=top:-3.23em;><span class=pstrut style=height:3em;></span><span class=frac-line style=border-bottom-width:0.04em;></span></span><span style=top:-3.677em;><span class=pstrut style=height:3em;></span><span class=mord><span class=mord><span class="mord mathnormal">L</span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:0.3175em;><span style=top:-2.55em;margin-left:0em;margin-right:0.05em;><span class=pstrut style=height:2.7em;></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">in</span></span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:0.15em;><span></span></span></span></span></span></span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:0.836em;><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style=top:-2.25em;><span class=pstrut style=height:3.3603em;></span><span class=mord><span class=mord></span><span class=mspace style=margin-right:0.2778em;></span><span class=mrel>=</span><span class=mspace style=margin-right:0.2778em;></span><span class=mord><span class="mopen nulldelimiter"></span><span class=mfrac><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:1.3214em;><span style=top:-2.314em;><span class=pstrut style=height:3em;></span><span class=mord><span class=mord>1.0</span><span class=mspace style=margin-right:0.2222em;></span><span class=mbin>+</span><span class=mspace style=margin-right:0.2222em;></span><span class=mord><span class="mord mathnormal">L</span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:0.3175em;><span style=top:-2.55em;margin-left:0em;margin-right:0.05em;><span class=pstrut style=height:2.7em;></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">in</span></span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:0.15em;><span></span></span></span></span></span></span></span></span><span style=top:-3.23em;><span class=pstrut style=height:3em;></span><span class=frac-line style=border-bottom-width:0.04em;></span></span><span style=top:-3.677em;><span class=pstrut style=height:3em;></span><span class=mord><span class=mord>1.0</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:0.836em;><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:2.2463em;><span></span></span></span></span></span></span></span></span></span></span></span><p>Hence</p><span class=katex-display><span class=katex><span class=katex-mathml><math display=block xmlns=http://www.w3.org/1998/Math/MathML><semantics><mtable columnalign="right left" columnspacing=0em rowspacing=0.25em><mtr><mtd><mstyle displaystyle=true scriptlevel=0><mrow><mrow><mi mathvariant=normal>T</mi><mi mathvariant=normal>M</mi><msub><mi mathvariant=normal>O</mi><mrow><mi mathvariant=normal>r</mi><mi mathvariant=normal>e</mi><mi mathvariant=normal>i</mi><mi mathvariant=normal>n</mi><mi mathvariant=normal>h</mi><mi mathvariant=normal>a</mi><mi mathvariant=normal>r</mi><mi mathvariant=normal>d</mi><mi mathvariant=normal>e</mi><mi mathvariant=normal>x</mi><mi mathvariant=normal>t</mi><mi mathvariant=normal>l</mi><mi mathvariant=normal>u</mi><mi mathvariant=normal>m</mi></mrow></msub></mrow><mo stretchy=false>(</mo><msub><mi>C</mi><mrow><mi mathvariant=normal>i</mi><mi mathvariant=normal>n</mi></mrow></msub><mo stretchy=false>)</mo></mrow></mstyle></mtd><mtd><mstyle displaystyle=true scriptlevel=0><mrow><mrow></mrow><mo>=</mo><msub><mi>C</mi><mrow><mi mathvariant=normal>i</mi><mi mathvariant=normal>n</mi></mrow></msub><mfrac><msub><mi>L</mi><mrow><mi mathvariant=normal>o</mi><mi mathvariant=normal>u</mi><mi mathvariant=normal>t</mi></mrow></msub><msub><mi>L</mi><mrow><mi mathvariant=normal>i</mi><mi mathvariant=normal>n</mi></mrow></msub></mfrac></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle displaystyle=true scriptlevel=0><mrow></mrow></mstyle></mtd><mtd><mstyle displaystyle=true scriptlevel=0><mrow><mrow></mrow><mo>=</mo><mfrac><msub><mi>C</mi><mrow><mi mathvariant=normal>i</mi><mi mathvariant=normal>n</mi></mrow></msub><mrow><mn>1.0</mn><mo>+</mo><msub><mi>L</mi><mrow><mi mathvariant=normal>i</mi><mi mathvariant=normal>n</mi></mrow></msub></mrow></mfrac></mrow></mstyle></mtd></mtr></mtable><annotation encoding=application/x-tex>\begin{aligned} \mathrm{TMO_{reinhardextlum}}(C_\mathrm{in}) &= C_\mathrm{in} \frac{L_\mathrm{out}}{L_\mathrm{in}} \\ &= \frac{C_\mathrm{in}}{1.0 + L_\mathrm{in}} \end{aligned}</annotation></semantics></math></span><span aria-hidden=true class=katex-html><span class=base><span class=strut style=height:4.9927em;vertical-align:-2.2463em;></span><span class=mord><span class=mtable><span class=col-align-r><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:2.7463em;><span style=top:-4.7463em;><span class=pstrut style=height:3.3603em;></span><span class=mord><span class=mord><span class="mord mathrm">TM</span><span class=mord><span class="mord mathrm">O</span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:0.3361em;><span style=top:-2.55em;margin-left:0em;margin-right:0.05em;><span class=pstrut style=height:2.7em;></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">reinhardextlum</span></span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:0.15em;><span></span></span></span></span></span></span></span><span class=mopen>(</span><span class=mord><span class="mord mathnormal" style=margin-right:0.07153em;>C</span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:0.3175em;><span style=top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;><span class=pstrut style=height:2.7em;></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">in</span></span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:0.15em;><span></span></span></span></span></span></span><span class=mclose>)</span></span></span><span style=top:-2.25em;><span class=pstrut style=height:3.3603em;></span><span class=mord></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:2.2463em;><span></span></span></span></span></span><span class=col-align-l><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:2.7463em;><span style=top:-4.7463em;><span class=pstrut style=height:3.3603em;></span><span class=mord><span class=mord></span><span class=mspace style=margin-right:0.2778em;></span><span class=mrel>=</span><span class=mspace style=margin-right:0.2778em;></span><span class=mord><span class="mord mathnormal" style=margin-right:0.07153em;>C</span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:0.3175em;><span style=top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;><span class=pstrut style=height:2.7em;></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">in</span></span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:0.15em;><span></span></span></span></span></span></span><span class=mord><span class="mopen nulldelimiter"></span><span class=mfrac><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:1.3603em;><span style=top:-2.314em;><span class=pstrut style=height:3em;></span><span class=mord><span class=mord><span class="mord mathnormal">L</span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:0.3175em;><span style=top:-2.55em;margin-left:0em;margin-right:0.05em;><span class=pstrut style=height:2.7em;></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">in</span></span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:0.15em;><span></span></span></span></span></span></span></span></span><span style=top:-3.23em;><span class=pstrut style=height:3em;></span><span class=frac-line style=border-bottom-width:0.04em;></span></span><span style=top:-3.677em;><span class=pstrut style=height:3em;></span><span class=mord><span class=mord><span class="mord mathnormal">L</span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:0.2806em;><span style=top:-2.55em;margin-left:0em;margin-right:0.05em;><span class=pstrut style=height:2.7em;></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">out</span></span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:0.15em;><span></span></span></span></span></span></span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:0.836em;><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style=top:-2.25em;><span class=pstrut style=height:3.3603em;></span><span class=mord><span class=mord></span><span class=mspace style=margin-right:0.2778em;></span><span class=mrel>=</span><span class=mspace style=margin-right:0.2778em;></span><span class=mord><span class="mopen nulldelimiter"></span><span class=mfrac><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:1.3603em;><span style=top:-2.314em;><span class=pstrut style=height:3em;></span><span class=mord><span class=mord>1.0</span><span class=mspace style=margin-right:0.2222em;></span><span class=mbin>+</span><span class=mspace style=margin-right:0.2222em;></span><span class=mord><span class="mord mathnormal">L</span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:0.3175em;><span style=top:-2.55em;margin-left:0em;margin-right:0.05em;><span class=pstrut style=height:2.7em;></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">in</span></span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:0.15em;><span></span></span></span></span></span></span></span></span><span style=top:-3.23em;><span class=pstrut style=height:3em;></span><span class=frac-line style=border-bottom-width:0.04em;></span></span><span style=top:-3.677em;><span class=pstrut style=height:3em;></span><span class=mord><span class=mord><span class="mord mathnormal" style=margin-right:0.07153em;>C</span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:0.3175em;><span style=top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;><span class=pstrut style=height:2.7em;></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">in</span></span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:0.15em;><span></span></span></span></span></span></span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:0.836em;><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:2.2463em;><span></span></span></span></span></span></span></span></span></span></span></span><h2 id=reinhard-jodie>Reinhard-Jodie<a aria-hidden=true class=zola-anchor href=#reinhard-jodie><img src=/images/link.svg></a></h2><p>You aren't necessarily forced to choose between tone mapping RGB individually and tone mapping luminance. Here's one such Reinhard variant by shadertoy user <a href=https://www.shadertoy.com/user/Jodie>Jodie</a> which does that:<pre class=language-cpp data-lang=cpp style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-cpp data-lang=cpp><span>vec3 reinhard_jodie(vec3 v)
</span><span>{
</span><span>    </span><span style=color:#569cd6;>float</span><span> l = luminance(v);
</span><span>    vec3 tv = v / (</span><span style=color:#b5cea8;>1.0</span><span style=color:#569cd6;>f </span><span>+ v);
</span><span>    </span><span style=color:#569cd6;>return </span><span>lerp(v / (</span><span style=color:#b5cea8;>1.0</span><span style=color:#569cd6;>f </span><span>+ l), tv, tv);
</span><span>}
</span></code></pre><p>The difference between this and the luminance-only tone map is barely noticeable in this scene (you can see that the stain glass windows are slightly less orange), but in other scenes (especially those with colored lights) the difference is more obvious. Note that there's also no way to set the white point with this TMO, but you could add a way yourself.<figure><img src=/images/tonemap/reinhard-jodie.png><figcaption><i>Reinhard-Jodie tone mapping</i></figcaption></figure><h1 id=filmic-tone-mapping-operators>Filmic Tone Mapping Operators<a aria-hidden=true class=zola-anchor href=#filmic-tone-mapping-operators><img src=/images/link.svg></a></h1><p>So-called 'filmic' TMOs are designed to emulate real film. Other than that, their defining feature is the distinctive 'toe' at the bottom end of the curve (radiance is on the <span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mi>x</mi></mrow><annotation encoding=application/x-tex>x</annotation></semantics></math></span><span aria-hidden=true class=katex-html><span class=base><span class=strut style=height:0.4306em;></span><span class="mord mathnormal">x</span></span></span></span> -axis, final pixel brightness is on the <span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mi>y</mi></mrow><annotation encoding=application/x-tex>y</annotation></semantics></math></span><span aria-hidden=true class=katex-html><span class=base><span class=strut style=height:0.625em;vertical-align:-0.1944em;></span><span class="mord mathnormal" style=margin-right:0.03588em;>y</span></span></span></span> -axis):<figure><img src=/images/tonemap/filmic-curve.png></figure><p>Note that the other end of the tone mapping curve is usually described as the 'shoulder'.<h2 id=uncharted-2>Uncharted 2<a aria-hidden=true class=zola-anchor href=#uncharted-2><img src=/images/link.svg></a></h2><p>A popular TMO for real-time graphics is the Uncharted 2 TMO devised by John Hable (sometimes known as 'Hable Tone Mapping' or 'Hable Filmic' etc). It has some parameters which can be tweaked, but the basic operator is given by the following code:<pre class=language-cpp data-lang=cpp style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-cpp data-lang=cpp><span>vec3 uncharted2_tonemap_partial(vec3 x)
</span><span>{
</span><span>    </span><span style=color:#569cd6;>float</span><span> A = </span><span style=color:#b5cea8;>0.15</span><span style=color:#569cd6;>f</span><span>;
</span><span>    </span><span style=color:#569cd6;>float</span><span> B = </span><span style=color:#b5cea8;>0.50</span><span style=color:#569cd6;>f</span><span>;
</span><span>    </span><span style=color:#569cd6;>float</span><span> C = </span><span style=color:#b5cea8;>0.10</span><span style=color:#569cd6;>f</span><span>;
</span><span>    </span><span style=color:#569cd6;>float</span><span> D = </span><span style=color:#b5cea8;>0.20</span><span style=color:#569cd6;>f</span><span>;
</span><span>    </span><span style=color:#569cd6;>float</span><span> E = </span><span style=color:#b5cea8;>0.02</span><span style=color:#569cd6;>f</span><span>;
</span><span>    </span><span style=color:#569cd6;>float</span><span> F = </span><span style=color:#b5cea8;>0.30</span><span style=color:#569cd6;>f</span><span>;
</span><span>    </span><span style=color:#569cd6;>return </span><span>((x</span><span style=color:#569cd6;>*</span><span>(A</span><span style=color:#569cd6;>*</span><span>x+C</span><span style=color:#569cd6;>*</span><span>B)+D</span><span style=color:#569cd6;>*</span><span>E)/(x</span><span style=color:#569cd6;>*</span><span>(A</span><span style=color:#569cd6;>*</span><span>x+B)+D</span><span style=color:#569cd6;>*</span><span>F))-E/F;
</span><span>}
</span><span>
</span><span>vec3 uncharted2_filmic(vec3 v)
</span><span>{
</span><span>    </span><span style=color:#569cd6;>float</span><span> exposure_bias = </span><span style=color:#b5cea8;>2.0</span><span style=color:#569cd6;>f</span><span>;
</span><span>    vec3 curr = uncharted2_tonemap_partial(v </span><span style=color:#569cd6;>*</span><span> exposure_bias);
</span><span>
</span><span>    vec3 W = vec3(</span><span style=color:#b5cea8;>11.2</span><span style=color:#569cd6;>f</span><span>);
</span><span>    vec3 white_scale = vec3(</span><span style=color:#b5cea8;>1.0</span><span style=color:#569cd6;>f</span><span>) / uncharted2_tonemap_partial(W);
</span><span>    </span><span style=color:#569cd6;>return</span><span> curr </span><span style=color:#569cd6;>*</span><span> white_scale;
</span><span>}
</span></code></pre><figure><img src=/images/tonemap/uncharted-2.png><figcaption><i>Uncharted 2 tone mapping</i></figcaption></figure><p>For some further reading, see <a href=http://filmicworlds.com/blog/filmic-tonemapping-with-piecewise-power-curves/>John Hable's blog post</a> about creating an improved curve which offers more intuitive controls.<h2 id=aces>ACES<a aria-hidden=true class=zola-anchor href=#aces><img src=/images/link.svg></a></h2><p>Another popular filmic tone mapping curve is ACES (Academy Color Encoding System). This is the default TMO used by Unreal Engine 4 so would be a perfectly good choice to use in your own real-time engine. The TMO curve is calculated through a couple of matrix transformations and formulae adapted from <a href=https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl>Stephen Hill's</a> fit, shown below:<pre class=language-cpp data-lang=cpp style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-cpp data-lang=cpp><span style=color:#569cd6;>static const</span><span> std::array&LTvec3, </span><span style=color:#b5cea8;>3</span><span>> aces_input_matrix =
</span><span>{
</span><span>    vec3(</span><span style=color:#b5cea8;>0.59719</span><span style=color:#569cd6;>f</span><span>, </span><span style=color:#b5cea8;>0.35458</span><span style=color:#569cd6;>f</span><span>, </span><span style=color:#b5cea8;>0.04823</span><span style=color:#569cd6;>f</span><span>),
</span><span>    vec3(</span><span style=color:#b5cea8;>0.07600</span><span style=color:#569cd6;>f</span><span>, </span><span style=color:#b5cea8;>0.90834</span><span style=color:#569cd6;>f</span><span>, </span><span style=color:#b5cea8;>0.01566</span><span style=color:#569cd6;>f</span><span>),
</span><span>    vec3(</span><span style=color:#b5cea8;>0.02840</span><span style=color:#569cd6;>f</span><span>, </span><span style=color:#b5cea8;>0.13383</span><span style=color:#569cd6;>f</span><span>, </span><span style=color:#b5cea8;>0.83777</span><span style=color:#569cd6;>f</span><span>)
</span><span>};
</span><span>
</span><span style=color:#569cd6;>static const</span><span> std::array&LTvec3, </span><span style=color:#b5cea8;>3</span><span>> aces_output_matrix =
</span><span>{
</span><span>    vec3( </span><span style=color:#b5cea8;>1.60475</span><span style=color:#569cd6;>f</span><span>, -</span><span style=color:#b5cea8;>0.53108</span><span style=color:#569cd6;>f</span><span>, -</span><span style=color:#b5cea8;>0.07367</span><span style=color:#569cd6;>f</span><span>),
</span><span>    vec3(-</span><span style=color:#b5cea8;>0.10208</span><span style=color:#569cd6;>f</span><span>,  </span><span style=color:#b5cea8;>1.10813</span><span style=color:#569cd6;>f</span><span>, -</span><span style=color:#b5cea8;>0.00605</span><span style=color:#569cd6;>f</span><span>),
</span><span>    vec3(-</span><span style=color:#b5cea8;>0.00327</span><span style=color:#569cd6;>f</span><span>, -</span><span style=color:#b5cea8;>0.07276</span><span style=color:#569cd6;>f</span><span>,  </span><span style=color:#b5cea8;>1.07602</span><span style=color:#569cd6;>f</span><span>)
</span><span>};
</span><span>
</span><span>vec3 mul(</span><span style=color:#569cd6;>const</span><span> std::array&LTvec3, </span><span style=color:#b5cea8;>3</span><span>></span><span style=color:#569cd6;>& </span><span>m, </span><span style=color:#569cd6;>const</span><span> vec3</span><span style=color:#569cd6;>& </span><span>v)
</span><span>{
</span><span>    </span><span style=color:#569cd6;>float</span><span> x = m[</span><span style=color:#b5cea8;>0</span><span>][</span><span style=color:#b5cea8;>0</span><span>] </span><span style=color:#569cd6;>*</span><span> v[</span><span style=color:#b5cea8;>0</span><span>] + m[</span><span style=color:#b5cea8;>0</span><span>][</span><span style=color:#b5cea8;>1</span><span>] </span><span style=color:#569cd6;>*</span><span> v[</span><span style=color:#b5cea8;>1</span><span>] + m[</span><span style=color:#b5cea8;>0</span><span>][</span><span style=color:#b5cea8;>2</span><span>] </span><span style=color:#569cd6;>*</span><span> v[</span><span style=color:#b5cea8;>2</span><span>];
</span><span>    </span><span style=color:#569cd6;>float</span><span> y = m[</span><span style=color:#b5cea8;>1</span><span>][</span><span style=color:#b5cea8;>0</span><span>] </span><span style=color:#569cd6;>*</span><span> v[</span><span style=color:#b5cea8;>1</span><span>] + m[</span><span style=color:#b5cea8;>1</span><span>][</span><span style=color:#b5cea8;>1</span><span>] </span><span style=color:#569cd6;>*</span><span> v[</span><span style=color:#b5cea8;>1</span><span>] + m[</span><span style=color:#b5cea8;>1</span><span>][</span><span style=color:#b5cea8;>2</span><span>] </span><span style=color:#569cd6;>*</span><span> v[</span><span style=color:#b5cea8;>2</span><span>];
</span><span>    </span><span style=color:#569cd6;>float</span><span> z = m[</span><span style=color:#b5cea8;>2</span><span>][</span><span style=color:#b5cea8;>0</span><span>] </span><span style=color:#569cd6;>*</span><span> v[</span><span style=color:#b5cea8;>1</span><span>] + m[</span><span style=color:#b5cea8;>2</span><span>][</span><span style=color:#b5cea8;>1</span><span>] </span><span style=color:#569cd6;>*</span><span> v[</span><span style=color:#b5cea8;>1</span><span>] + m[</span><span style=color:#b5cea8;>2</span><span>][</span><span style=color:#b5cea8;>2</span><span>] </span><span style=color:#569cd6;>*</span><span> v[</span><span style=color:#b5cea8;>2</span><span>];
</span><span>    </span><span style=color:#569cd6;>return </span><span>vec3(x, y, z);
</span><span>}
</span><span>
</span><span>vec3 rtt_and_odt_fit(vec3 v)
</span><span>{
</span><span>    vec3 a = v </span><span style=color:#569cd6;>* </span><span>(v + </span><span style=color:#b5cea8;>0.0245786</span><span style=color:#569cd6;>f</span><span>) - </span><span style=color:#b5cea8;>0.000090537</span><span style=color:#569cd6;>f</span><span>;
</span><span>    vec3 b = v </span><span style=color:#569cd6;>* </span><span>(</span><span style=color:#b5cea8;>0.983729</span><span style=color:#569cd6;>f *</span><span> v + </span><span style=color:#b5cea8;>0.4329510</span><span style=color:#569cd6;>f</span><span>) + </span><span style=color:#b5cea8;>0.238081</span><span style=color:#569cd6;>f</span><span>;
</span><span>    </span><span style=color:#569cd6;>return</span><span> a / b;
</span><span>}
</span><span>
</span><span>vec3 aces_fitted(vec3 v)
</span><span>{
</span><span>    v = mul(aces_input_matrix, v);
</span><span>    v = rtt_and_odt_fit(v);
</span><span>    </span><span style=color:#569cd6;>return </span><span>mul(aces_output_matrix, v);
</span><span>}
</span></code></pre><figure><img src=/images/tonemap/aces.png><figcaption><i>ACES tone mapping</i></figcaption></figure><p>You can also use this approximated ACES fit by <a href=https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/>Krzysztof Narkowicz</a> for something a bit more performant. Note that this approximation oversaturates bright colors slightly compared to the better fit (you can see that in the middle stained glass window).<pre class=language-cpp data-lang=cpp style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-cpp data-lang=cpp><span>vec3 aces_approx(vec3 v)
</span><span>{
</span><span>    v *= </span><span style=color:#b5cea8;>0.6</span><span style=color:#569cd6;>f</span><span>;
</span><span>    </span><span style=color:#569cd6;>float</span><span> a = </span><span style=color:#b5cea8;>2.51</span><span style=color:#569cd6;>f</span><span>;
</span><span>    </span><span style=color:#569cd6;>float</span><span> b = </span><span style=color:#b5cea8;>0.03</span><span style=color:#569cd6;>f</span><span>;
</span><span>    </span><span style=color:#569cd6;>float</span><span> c = </span><span style=color:#b5cea8;>2.43</span><span style=color:#569cd6;>f</span><span>;
</span><span>    </span><span style=color:#569cd6;>float</span><span> d = </span><span style=color:#b5cea8;>0.59</span><span style=color:#569cd6;>f</span><span>;
</span><span>    </span><span style=color:#569cd6;>float</span><span> e = </span><span style=color:#b5cea8;>0.14</span><span style=color:#569cd6;>f</span><span>;
</span><span>    </span><span style=color:#569cd6;>return </span><span>clamp((v</span><span style=color:#569cd6;>*</span><span>(a</span><span style=color:#569cd6;>*</span><span>v+b))/(v</span><span style=color:#569cd6;>*</span><span>(c</span><span style=color:#569cd6;>*</span><span>v+d)+e), </span><span style=color:#b5cea8;>0.0</span><span style=color:#569cd6;>f</span><span>, </span><span style=color:#b5cea8;>1.0</span><span style=color:#569cd6;>f</span><span>);
</span><span>}
</span></code></pre><figure><img src=/images/tonemap/aces-worse.png><figcaption><i>ACES tone mapping (worse fit)</i></figcaption></figure><h1 id=real-camera-response-functions>Real Camera Response Functions<a aria-hidden=true class=zola-anchor href=#real-camera-response-functions><img src=/images/link.svg></a></h1><p>Sometimes it might be desireable to exactly reproduce the 'tone mapping' response of a real camera. Fortunately, the University of Columbia has released a <a href=http://web.archive.org/web/20191226154550/http://cs.columbia.edu/CAVE/software/softlib/dorf.php>database of camera response functions</a> which we can use for this purpose. Each camera response curve has two axes: irradiance (essentially the energy coming into the camera) and intensity (essentially the value of color component at that point on the film).<p>Since irradiance is the input and intensity is the output, you can visualise irradiance and intensity on the <span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mi>x</mi></mrow><annotation encoding=application/x-tex>x</annotation></semantics></math></span><span aria-hidden=true class=katex-html><span class=base><span class=strut style=height:0.4306em;></span><span class="mord mathnormal">x</span></span></span></span> and <span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mi>y</mi></mrow><annotation encoding=application/x-tex>y</annotation></semantics></math></span><span aria-hidden=true class=katex-html><span class=base><span class=strut style=height:0.625em;vertical-align:-0.1944em;></span><span class="mord mathnormal" style=margin-right:0.03588em;>y</span></span></span></span> axes respectively. The data given to us has the points on both axes normalized into the range <span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mo stretchy=false>[</mo><mn>0.0</mn><mo separator=true>,</mo><mn>1.0</mn><mo stretchy=false>]</mo></mrow><annotation encoding=application/x-tex>[0.0, 1.0]</annotation></semantics></math></span><span aria-hidden=true class=katex-html><span class=base><span class=strut style=height:1em;vertical-align:-0.25em;></span><span class=mopen>[</span><span class=mord>0.0</span><span class=mpunct>,</span><span class=mspace style=margin-right:0.1667em;></span><span class=mord>1.0</span><span class=mclose>]</span></span></span></span> . For intensity, this is exactly what we want, as we can just scale the output by 256 to get the corresponding 8-bit color component. For irradiance, we will need to decide the 'width' of the curve. Since the point with the largest <span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mi>x</mi></mrow><annotation encoding=application/x-tex>x</annotation></semantics></math></span><span aria-hidden=true class=katex-html><span class=base><span class=strut style=height:0.4306em;></span><span class="mord mathnormal">x</span></span></span></span> value is <span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mo stretchy=false>(</mo><mn>1.0</mn><mo separator=true>,</mo><mn>1.0</mn><mo stretchy=false>)</mo></mrow><annotation encoding=application/x-tex>(1.0, 1.0)</annotation></semantics></math></span><span aria-hidden=true class=katex-html><span class=base><span class=strut style=height:1em;vertical-align:-0.25em;></span><span class=mopen>(</span><span class=mord>1.0</span><span class=mpunct>,</span><span class=mspace style=margin-right:0.1667em;></span><span class=mord>1.0</span><span class=mclose>)</span></span></span></span> , if we stretch this curve horizontally by a factor of <span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mi>a</mi></mrow><annotation encoding=application/x-tex>a</annotation></semantics></math></span><span aria-hidden=true class=katex-html><span class=base><span class=strut style=height:0.4306em;></span><span class="mord mathnormal">a</span></span></span></span> then the new furthest point will be <span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mo stretchy=false>(</mo><mi>a</mi><mo separator=true>,</mo><mn>1.0</mn><mo stretchy=false>)</mo></mrow><annotation encoding=application/x-tex>(a, 1.0)</annotation></semantics></math></span><span aria-hidden=true class=katex-html><span class=base><span class=strut style=height:1em;vertical-align:-0.25em;></span><span class=mopen>(</span><span class="mord mathnormal">a</span><span class=mpunct>,</span><span class=mspace style=margin-right:0.1667em;></span><span class=mord>1.0</span><span class=mclose>)</span></span></span></span> . We can map any irradiance value greater than <span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mi>a</mi></mrow><annotation encoding=application/x-tex>a</annotation></semantics></math></span><span aria-hidden=true class=katex-html><span class=base><span class=strut style=height:0.4306em;></span><span class="mord mathnormal">a</span></span></span></span> to <span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mn>1.0</mn></mrow><annotation encoding=application/x-tex>1.0</annotation></semantics></math></span><span aria-hidden=true class=katex-html><span class=base><span class=strut style=height:0.6444em;></span><span class=mord>1.0</span></span></span></span> and hence we can effectively control the white point by stretching or squashing the irradiance axis. Instead of 'white point', we'll call this parameter 'ISO' which mimics the function of the ISO setting on a real-world camera.<p>The data is given as two associative arrays. Given a irradiance value in <span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mo stretchy=false>[</mo><mn>0.0</mn><mo separator=true>,</mo><mn>1.0</mn><mo stretchy=false>]</mo></mrow><annotation encoding=application/x-tex>[0.0, 1.0]</annotation></semantics></math></span><span aria-hidden=true class=katex-html><span class=base><span class=strut style=height:1em;vertical-align:-0.25em;></span><span class=mopen>[</span><span class=mord>0.0</span><span class=mpunct>,</span><span class=mspace style=margin-right:0.1667em;></span><span class=mord>1.0</span><span class=mclose>]</span></span></span></span> we need to find the index into the irradiance array (ideally using a binary search). Then, we can compute the output value by using the index we got from that binary search to look up the intensity value from the intensity array. We'll repeat this procedure for each RGB channel individually to compute the final color.<p>For real-time graphics you might want to find a way to bake a LUT instead of doing a relatively expensive binary search.<pre class=language-cpp data-lang=cpp style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-cpp data-lang=cpp><span style=color:#569cd6;>float </span><span>camera_get_intensity(</span><span style=color:#569cd6;>float </span><span>f, </span><span style=color:#569cd6;>float </span><span>iso)
</span><span>{
</span><span>    f = clamp(f, </span><span style=color:#b5cea8;>0.0</span><span style=color:#569cd6;>f</span><span>, iso); </span><span style=color:#608b4e;>// Clamp to [0.0, iso]
</span><span>    f /= iso; </span><span style=color:#608b4e;>// Convert to [0.0, 1.0]
</span><span>
</span><span>    </span><span style=color:#608b4e;>// Returns 1.0 if the index is out-of-bounds
</span><span>    </span><span style=color:#569cd6;>auto</span><span> get_or_one = [](</span><span style=color:#569cd6;>const auto&</span><span> arr, size_t index)
</span><span>    {
</span><span>        </span><span style=color:#569cd6;>return</span><span> index < arr.size() </span><span style=color:#569cd6;>?</span><span> arr[index] </span><span style=color:#569cd6;>: </span><span style=color:#b5cea8;>1.0</span><span>;
</span><span>    };
</span><span>
</span><span>    </span><span style=color:#608b4e;>// std::upper_bound uses a binary search to find the position of f in camera_irradiance
</span><span>    </span><span style=color:#569cd6;>auto</span><span> upper = std::upper_bound(camera_irradiance.begin(), camera_irradiance.end(), f);
</span><span>    size_t idx = std::distance(camera_irradiance.begin(), upper);
</span><span>
</span><span>    </span><span style=color:#569cd6;>double</span><span> low_irradiance = camera_irradiance[idx];
</span><span>    </span><span style=color:#569cd6;>double</span><span> high_irradiance = get_or_one(camera_irradiance, idx + </span><span style=color:#b5cea8;>1</span><span>);
</span><span>    </span><span style=color:#569cd6;>double</span><span> lerp_param = (f - low_irradiance) / (high_irradiance - low_irradiance);
</span><span>
</span><span>    </span><span style=color:#569cd6;>double</span><span> low_val = camera_intensity[idx];
</span><span>    </span><span style=color:#569cd6;>double</span><span> high_val = get_or_one(camera_intensity, idx + </span><span style=color:#b5cea8;>1</span><span>);
</span><span>
</span><span>    </span><span style=color:#608b4e;>// Lerping isn't really necessary for RGB8 (as the curve is sampled with 1024 points)
</span><span>    </span><span style=color:#569cd6;>return </span><span>clamp(lerp((</span><span style=color:#569cd6;>float</span><span>)low_val, (</span><span style=color:#569cd6;>float</span><span>)high_val, (</span><span style=color:#569cd6;>float</span><span>)lerp_param), </span><span style=color:#b5cea8;>0.0</span><span style=color:#569cd6;>f</span><span>, </span><span style=color:#b5cea8;>1.0</span><span style=color:#569cd6;>f</span><span>);
</span><span>}
</span><span>
</span><span>vec3 camera_tonemap(vec3 v, </span><span style=color:#569cd6;>float </span><span>iso)
</span><span>{
</span><span>    </span><span style=color:#569cd6;>float</span><span> r = camera_get_intensity(v.r(), iso);
</span><span>    </span><span style=color:#569cd6;>float</span><span> g = camera_get_intensity(v.g(), iso);
</span><span>    </span><span style=color:#569cd6;>float</span><span> b = camera_get_intensity(v.b(), iso);
</span><span>    </span><span style=color:#569cd6;>return </span><span>vec3(r, g, b);
</span><span>}
</span></code></pre><figure><img src=/images/tonemap/camera-response.png><figcaption><i>DSCS315-R1 response curve, ISO = 6.0</i></figcaption></figure><p>This method is available as an option in <a href=https://www.indigorenderer.com/documentation/manual/rendering-with-indigo/camera/tone-mapping>Indigo Renderer</a>, for the curious.<h1 id=local-tone-mapping-operators>Local Tone Mapping Operators<a aria-hidden=true class=zola-anchor href=#local-tone-mapping-operators><img src=/images/link.svg></a></h1><p>So far, all the TMOs I've discussed have been <em>global tone mapping operators</em>. This means that the computation they do is only based on the input radiance value and global image parameters like the average luminance. Tone mapping operators which are a function of position are known as <em>local tone mapping operators</em>. These are generally far more expensive and hence unsuitable for real time graphics - yet widely used in digital photography. Local TMOs can also give strange results when applied to video.<p>One local tone mapping operator is described in the <a href=https://www.cs.utah.edu/docs/techreports/2002/pdf/UUCS-02-001.pdf>same paper by Reinhard et al.</a> - it involves a digital simulation of a process known as 'dodging and burning' in real photography, which essentially applies different exposure to different regions of the image, often resulting in more detailed images than global tone mapping operators are able to produce.<h1 id=conclusion>Conclusion<a aria-hidden=true class=zola-anchor href=#conclusion><img src=/images/link.svg></a></h1><p>Hopefully this guide was instructive. I've placed a grid of all TMOs used here for comparison, <strong>but keep in mind that these can be adjusted in certain ways through exposure or other parameters, so this isn't entirely a fair comparison</strong>.<div class=image-grid-row><div class=image-grid-col><figure><img src=/images/tonemap/clamp.png><figcaption><i>Clamp</i></figcaption></figure></div><div class=image-grid-col><figure><img src=/images/tonemap/reinhard.png><figcaption><i>Reinhard simple</i></figcaption></figure></div></div><div class=image-grid-row><div class=image-grid-col><figure><img src=/images/tonemap/reinhard-luminance.png><figcaption><i>Reinhard luminance (white point = max luminance)</i></figcaption></figure></div><div class=image-grid-col><figure><img src=/images/tonemap/reinhard-jodie.png><figcaption><i>Reinhard-Jodie</i></figcaption></figure></div></div><div class=image-grid-row><div class=image-grid-col><figure><img src=/images/tonemap/uncharted-2.png><figcaption><i>Uncharted 2</i></figcaption></figure></div><div class=image-grid-col><figure><img src=/images/tonemap/aces.png><figcaption><i>ACES</i></figcaption></figure></div></div><div class=image-grid-row><div class=image-grid-col><figure><img src=/images/tonemap/aces-worse.png><figcaption><i>ACES (worse fit)</i></figcaption></figure></div><div class=image-grid-col><figure><img src=/images/tonemap/camera-response.png><figcaption><i>DSCS315-R1 (ISO = 6.0)</i></figcaption></figure></div></div><h2 id=further-reading>Further Reading<a aria-hidden=true class=zola-anchor href=#further-reading><img src=/images/link.svg></a></h2><ul><li><a href=https://www.cl.cam.ac.uk/%7Erkm38/pdfs/mantiuk15hdri.pdf><em>High Dynamic Range Imaging Book</em></a>, R. Mantiuk et al.<li><a href=http://filmicworlds.com/blog/><em>Filmic Worlds Blog</em></a> - John Hable<li><a href=https://www.cl.cam.ac.uk/%7Erkm38/pdfs/tone_mapping.pdf><em>Tone Mapping (slides)</em></a> - R. Mantiuk<li><a href=http://seenaburns.com/dynamic-range/><em>Dynamic Range, Exposure and Tone Mapping</em></a> - Seena Burns</ul><h2 id=appendix>Appendix<a aria-hidden=true class=zola-anchor href=#appendix><img src=/images/link.svg></a></h2><p>The full source code for this post can be found <a href=https://github.com/64/64.github.io/blob/src/code/tonemapping>on my GitHub</a>. For the <code>vec3</code> class, I'm using a <a href=https://github.com/64/64.github.io/blob/src/code/tonemapping/vec3.h>slightly modified version</a> of the one found in Shirley's '<a href=http://www.realtimerendering.com/raytracing/Ray%20Tracing%20in%20a%20Weekend.pdf>Ray Tracing in One Weekend</a>' book.<p><em>This guide was initially created by me for the <a href=https://graphicsprogramming.github.io/resources/>Graphics Programming Discord Resources</a></em>.</div><div class=post-footer><div class=post-nav><a class=next href=https://64.github.io/actix/>Why we need alternatives to Actix ›</a></div></div><script>var disqus_config = function () {
                    this.page.url = "https://64.github.io/tonemapping/";
                    this.page.identifier = "tonemapping";
                };</script><div id=disqus_thread></div><script>(function() { var d = document, s = d.createElement('script'); s.src = 'https://64-github-io.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); document.addEventListener('colorSchemeChanged', function (e) { if (document.readyState == 'complete') { DISQUS.reset({ reload: true }); } });</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></article></div></main></div><script defer src=https://64.github.io/theme.js></script><script src=https://64.github.io/even.js></script>